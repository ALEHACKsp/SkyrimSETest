//
//
// BloodSplatter
//
// Possible technique defines:
// - SPLATTER
// - FLARE
//
//
#ifndef WINPC
#error Shader is only for Windows
#endif

#ifndef DX11
#error Shader is only for DirectX 11
#endif

#if defined(SPLATTER) && defined(FLARE)
#error Multiple base techniques defined
#endif

#if !defined(SPLATTER) && !defined(FLARE)
#error No base technique defined
#endif

struct VS_INPUT
{
	float4 Position : POSITION0;
	float2 TexCoord : TEXCOORD0;
};

// AKA vertex shader output
struct PS_INPUT
{
	float4 v0 : SV_POSITION0;
	float3 v1 : TEXCOORD0;
    
#if defined(SPLATTER)
	float2 v2 : TEXCOORD1;
#endif
};

struct PS_OUTPUT
{
	float4 o0 : SV_Target0;
};

//
// Vertex shader code
//
#ifdef VSHADER
cbuffer PerTechnique : register(b0)
{
};

cbuffer PerMaterial : register(b1)
{
};

cbuffer PerGeometry : register(b2)
{
	row_major float4x4 WorldViewProj;
	float4 LightLoc;
	float Ctrl;
};

PS_INPUT vs_main(VS_INPUT input)
{
	PS_INPUT vsout;
	
#if defined(SPLATTER)
    float4 position = float4(input.Position.xy, 0.0, 1.0);
    float4 projected = mul(WorldViewProj, float4(input.Position.xy, 0.0, 1.0));

    float2 r1 = (-LightLoc.xy + projected.xy) * LightLoc.ww;

    vsout.v0 = projected;
    vsout.v1 = float3(input.TexCoord, input.Position.z);
	vsout.v2 = -r1.xy * float2(-0.5, 0.5) + input.TexCoord;
#elif defined(FLARE)
	float4 r0,r1;
	r0.xy = input.Position.xy;
	r0.z = 1;
	r1.x = dot(WorldViewProj[0].xyw, r0.xyz);
	r1.y = dot(WorldViewProj[1].xyw, r0.xyz);
	r1.zw = -LightLoc.xy + r1.xy;
	r1.zw = LightLoc.ww * r1.zw;
	vsout.v0.xy = r1.zw * Ctrl.xx + r1.xy;
	vsout.v0.z = dot(WorldViewProj[2].xyw, r0.xyz);
	vsout.v0.w = dot(WorldViewProj[3].xyw, r0.xyz);
	vsout.v1.xy = input.TexCoord.xy;
	vsout.v1.z = input.Position.z;
#endif

	return vsout;
}
#endif

//
// Pixel shader code
//
#ifdef PSHADER
SamplerState BloodColorSamp : register(s0);
SamplerState BloodAlphaSamp : register(s1);
SamplerState FlareColorSamp : register(s2);
SamplerState FlareHDRSamp : register(s3);

Texture2D<float4> BloodColorTex : register(t0);
Texture2D<float4> BloodAlphaTex : register(t1);
Texture2D<float4> FlareColorTex : register(t2);
Texture2D<float4> FlareHDRTex : register(t3);

cbuffer PerTechnique : register(b0)
{
};

cbuffer PerMaterial : register(b1)
{
};

cbuffer PerGeometry : register(b2)
{
	float Alpha;
};

PS_OUTPUT ps_main(PS_INPUT input)
{
	PS_OUTPUT psout;
	float4 r0,r1;
	
#if defined(SPLATTER)
	r0.xyz = BloodAlphaTex.Sample(BloodAlphaSamp, input.v2.xy).xyz;
	r1.xyzw = BloodColorTex.Sample(BloodColorSamp, input.v1.xy).xyzw;
	r1.xyz = float3(-1,-1,-1) + r1.xyz;
	r0.w = Alpha * input.v1.z;
	r0.w = r1.w * r0.w;
	r1.xyz = r0.www * r1.xyz + float3(1,1,1);
	r0.xyz = -r1.xyz + r0.xyz;
	psout.o0.xyz = r0.www * r0.xyz + r1.xyz;
	psout.o0.w = 1;
#elif defined(FLARE)
	r0.x = FlareColorTex.Sample(FlareColorSamp, input.v1.xy).x;
	r1.xyzw = FlareHDRTex.Sample(FlareHDRSamp, input.v1.xy).xyzw;
	r0.xyzw = r1.xyzw * r0.xxxx;
	psout.o0.xyzw = Alpha * r0.xyzw;
#endif
  
	return psout;
}
#endif